package com.nit.hk.collection;

import java.lang.foreign.Linker.Option;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/*
 * 1. Java 8 introduced a new feature called streams, 
 * 	  which is a powerful and concise way of processing 
 * 	  collection of objects. 
 * 
 * 2. A Stream is as sequence of elements(objects),
 *    nothing but flow of objects
 *    
 * 3. A stream is meant for "processing data" in a 
 *    "functional programming style approach"
 * 	  that is both easy to read and write.
 * 
 * 4. In Java 8, a stream is a sequence of elements 
 *    that can be processed either sequentially or in parallel.
 *     
 * 5. Streams are designed to be used with collections, 
 * 	  but they can also be used with arrays, I/O channels, 
 *      and other data sources.
 * 
 * 6. Streams allow developers to write concise and efficient code 
 *    that is easy to read and understand. 
 * 
 * 7. Stream is typically divided into 3 categories:
 * 	  means a stream has 3 parts 
 *			1. Source
 * 		2. Intermediate operations and 
 *			3. Terminal operations.
 *  
 *  	- Source is a collection or an array object 
 *        from which we can create a stream object	
 *
 *  	- Intermediate operations are the middle operations 
 *        which are meant for processing data and generate result
 *        as a new stream object. That means every intermediate operation
 *        return new stream object with this new result. 
 *
 *  	- Where as terminal operation are the last operations 
 *        those are meant for reading, returning, saving and 
 *        displaying result that is generated by intermediate operations.
 *        The terminal operation does not return Stream object, rather
 *        it returns the result available in this stream object.
 *  
 *  Intermediate operations are used to transform or filter the data 
 *  in a stream,while terminal operations are used to produce a result 
 *  or side-effect. 
 *  
 *  Some examples of intermediate operations include 
 *  	filter, map, and flatMap, 
 *  
 *  while examples of terminal operations include 
 *  	forEach, reduce, and collect.
 *  
 *  Here's an example of using streams in Java 8 
 *  to filter a list of strings and then print them out:
 *  
 *  List<String> names = Arrays.asList("HK", "BK", "BH", "PK", "SK");
 *  
 *  	names.stream()							//source
 *    	 .filter(name -> name.contains("H"))	//intermediate operation
 *    	 .forEach(System.out::println);			//terminal operation
 *    
 * 		This code will create a stream of names, 
 * 		filter out any names that don't have "H", 
 *  	and then print out the remaining names. 
 *  
 *  The output will be:
 *  	HK
 *  	BH
 *  
 *  Note: 
 *  1. We can apply any number of intermediate operations
 *     but we can apply only one terminal operation. 
 *  
 *  2. Every intermediate operation will return new Stream object with result.
 *     Terminal operation does not return Stream object, it just allows us
 *     either read or return final result.
 *     
 *  3. After one intermediate operation we can proceed to 
 *      more aggregate intermediate operations, but after terminal operation 
 *      we can not proceed further on this stream    
 *  
 * Intermediate operations
	The Stream interface in Java 8 provides a set of 
	intermediate operations that can be used to transform or filter 
	the elements in a stream. Here are some of the most	commonly used 
	intermediate operations:
	
	1. filter(Predicate<T> predicate): This operation filters the elements in the 
		stream based on a given predicate and returns a new stream with only the 
		filtered elements.

	2. map(Function<T, R> mapper): This operation applies a function to each element in 
		the stream and returns a new stream with the transformed elements.

	3. flatMap(Function<T, Stream<R>> mapper): This operation applies a function that	
		returns a stream to each element in the stream, and then flattens the 
		resulting streams into a single stream.

	4. distinct(): This operation returns a new stream with only the distinct elements	
		from the original stream.

	5. sorted(): This operation returns a new stream with the elements sorted in 
		natural order.

	6. sorted(Comparator<T> comparator): This operation returns a new stream with the 
		elements sorted based on a given comparator.

	7. peek(Consumer<T> action): This operation applies a consumer to each element in	
		the stream and returns a new stream with the same elements.

	8. limit(long maxSize): This operation returns a new stream with only the first
		maxSize elements from the original stream.

	9. skip(long n): This operation returns a new stream with all the elements from the 
		original stream except for the first n elements.

	These intermediate operations are useful for transforming, filtering, and 
	manipulating the elements in a stream before performing a terminal operation. By 
	chaining multiple intermediate operations together, you can create complex stream 
	pipelines that perform advanced data processing tasks.
   
 * Terminal operations
	The Stream interface in Java 8 provides a set of terminal operations that can be 
	used to produce a result or side-effect. Here are some of the most commonly used 
	terminal operations:

	1. forEach(Consumer<T> action): This operation applies a consumer to each element 
		in the stream.

	2. toArray(): This operation returns an array containing the elements of the 
		stream.

	3. reduce(BinaryOperator<T> accumulator): This operation applies a binary operator 
		to the elements in the stream and returns a result.

	4. collect(Collector<T,A,R> collector): This operation collects the elements in the 
		stream into a collection or other data structure.

	5. min(Comparator<T> comparator): This operation returns the minimum element in the 
		stream based on a given comparator.

	6. max(Comparator<T> comparator): This operation returns the maximum element in the 
		stream based on a given comparator.

	7. count(): This operation returns the number of elements in the stream.

	8. anyMatch(Predicate<T> predicate): This operation returns true if any element in 
		the stream matches a given predicate.

	9. allMatch(Predicate<T> predicate): This operation returns true if all elements in	
		the stream match a given predicate.

	10. noneMatch(Predicate<T> predicate): This operation returns true if no element in 
		the stream matches a given predicate.

	These terminal operations are used to produce a result or side-effect after 
	performing intermediate operations on a stream. By combining intermediate and 
	terminal operations, you can create powerful stream pipelines that perform complex 
	data processing tasks.  
*/
public class Test31_Stream_API {
	public static void main(String[] args) {
					ArrayList<Object> al = new ArrayList<>();
					
					al.add("a");
					al.add(5);
					al.add("b");
					al.add(6);
					al.add("c");
					al.add(7);
					
	//1. Retrieving and printing all objects available in this collection
					al.stream()
							.forEach(ele -> System.out.println(ele));
					System.out.println();
					
	//2. Retrieving and printing only String objects
					al.stream()
									.filter(ele -> ele instanceof String)
									.forEach(ele -> System.out.println(ele));
					System.out.println();
		
	//3. Retrieving and printing only Integer objects
					al.stream()
									.filter(ele -> ele instanceof Integer)
									.forEach(ele -> System.out.println(ele));
					System.out.println();
					
	//4. Retrieving and printing only only even Integer objects
					al.stream()
									.filter(ele -> ele instanceof Integer)
									.filter(ele -> ((int)ele)%2==0)
									.forEach(ele -> System.out.println(ele));
					System.out.println();
					
	//5. converting String objects to their upper case and printing
					al.stream()
									.filter(ele -> ele instanceof String)													//[a, b, c]
									.map(ele -> ((String)ele).toUpperCase())										//[A, B, C]
									.forEach(ele -> System.out.println(ele));										//printing
					System.out.println();
					
	//6. Count number of even objects available in the collection
					System.out.println(al);
					long count = al.stream()
													.filter(ele -> ele instanceof Integer)
													.filter(ele -> ((int)ele)%2==0)
													.count();
					System.out.println("number of integers: "+count);
					System.out.println();
					
	//6. retrieving the even objects available in the collection
					System.out.println(al);
					List<Object> evenNumberlist = al.stream()	
																					.filter(ele -> ele instanceof Integer)
																					.filter(ele -> ((int)ele)%2==0)
																					.toList();
					System.out.println("The even numbers available: " + evenNumberlist);
					System.out.println();
					
	//7. retrieving the max number available in the collection
					System.out.println(al);
					Optional<Object> max = al.stream()
																			.filter(ele -> ele instanceof Integer)
																			.max((o1, o2) -> ((Integer)o1).compareTo((Integer)o2));
					System.out.println("The max value available: " + max);
					
					Object maxValue = max.get();
					System.out.println(maxValue);
					System.out.println();
					
	//8. retrieving the min number available in the collection
					Optional<Object> min = al.stream()
																			.filter(ele -> ele instanceof Integer)
																			.min((o1, o2) -> ((Integer)o1).compareTo((Integer)o2));
					System.out.println("The min value available: " + min);
					
					Object minValue = min.get();
					System.out.println(minValue);
					System.out.println();
	}
}
